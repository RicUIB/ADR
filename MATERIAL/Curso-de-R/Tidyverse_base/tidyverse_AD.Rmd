---
title: "Introducción a  ciencia de datos: tidyverse"
author: ""
date: '10-2022'
output:
  beamer_presentation: 
    includes:
      in_header: header_pagenrs_complet.tex
    theme: CambridgeUS
    toc: yes
    slide_level: 2
    keep_tex: yes
  slidy_presentation:
    incremental: no
  ioslides_presentation:
    incremental: no
    widescreen: true
lang: es-ES
linkcolor: green
classoption: aspectratio=169 
---


```{r setup, include=FALSE}
#AnnArbor 
#linkcolor: #191970
knitr::opts_chunk$set(echo = TRUE, comment = NA,cache=TRUE)
library(tidyverse)
```

# Introducción

## La librerías de `tidyverse`

\blue{Tidyverse}  es una  colección de paquetes/librerías  de R para ciencia de datos con diseño similar [tidyverse.org](https://www.tidyverse.org/)

\red{ La idea principal es establecer una tecnología que aproxime el lenguaje natural a la manipulación de datos} [Wickham, et al. (2019)](https://joss.theoj.org/papers/10.21105/joss.01686){width="30%"}

[Hadley Wickham](https://hadley.nz/) es el director de los científicos de datos de RStudio y profesor adjunto de estadística en la Universidad de Auckland, la Universidad de Stanford y la Universidad de Rice. 

Las librerías de tidyverse han venido a sustituir R base por su eficiencia y facilidad de programación para no informáticos.

Casi todas las consultas  a páginas técnicas de R son o incluyen código de `tidyverse`.


```{r, echo=FALSE, out.width='10%',fig.align='right'}
knitr::include_graphics("Imgs/hex-tidyverse.png")
```



## Las librerías de `tidyverse`

**Paquetes de `tidyverse` base :**

* `readr`: lectura de datos
* `tibble`: una clase 'tbl_df' (el 'tibble') con una comprobación más estricta y un mejor formato que el data frame tradicional.
* `stringr`: paquete de funciones para texto
* `forcats`: paquete de funciones para factores
* `tidyr`:  arreglo y limpieza de datos 
* `dplyr`: manipulación de datos
* `ggplot2`:   visualización de datos (gráficos)
* `purrr`: programación funcional (pipes)


Hay muchos otros paquetes para fines especiales que se integran sin problemas, por ejemplo, lubridate (variables de tiempo), stringr (texto), forcats (factores), ...

```{r, echo=F, out.width='5%', fig.align='right'}
knitr::include_graphics("Imgs/hex-tidyverse.png")
```

## Instalar y cargar `tidyverse`

```{r,warning=FALSE, message=TRUE}
#install.packages("tidyverse")
library(tidyverse)
```
```
-- Attaching packages --------------------------------------- tidyverse 1.3.1 --
v ggplot2 3.3.5 v purrr 0.3.4
v tibble 3.1.4 v dplyr 1.0.7
v tidyr 1.1.3 v stringr 1.4.0
v readr 2.0.1 v forcats 0.5.1
-- Conflicts ------------------------------------------ tidyverse_conflicts() --
x dplyr::filter() masks stats::filter()
x dplyr::lag() masks stats::lag()
```


Se puede ver la versión del paquete tidyverse y la de los paquetes base de tidyverse.

\red{Cuidado que algunas funciones de R se sobrescriben por sus equivalentes de tidyverse.} 

En ocasiones es preferible indicar explícitamente el nombre de la función que deseamos utilizar, por ejemplo: `dplyr::group_by` para distinguir de `plyr::group_by` (dplyr es una evolución del paquete plyr) .


##  Más sobre `tidyverse`

Todos estos paquetes están pensados para:

1. Tener una tecnología  en la que puedan convivir desde informáticos  puros, economistas, matemáticos, gestores etc.  compartiendo el mismo flujo de datos...

2. Facilitar el análisis y modelización de datos


```{r, echo=F, out.width='60%', fig.align="center"}
knitr::include_graphics("Imgs/data-science.png")
```

## Librerías para cada tarea


```{r, echo=F, out.width='30%', fig.align="center"}
knitr::include_graphics("Imgs/data-science.png")
```
* **Import:** `readr`  
* **Tidy:** `tidyr`  
* **Transform:** `dplyr`, `forcats`, `stringr`  
* **Visualize:** `ggplot2`  
* **Model:** `tidymodels`  
* **Communicate:** `rmarkdown`  
* **Program:** `magrittr`, `purrr`, `tibble`


Algunos libros:

* [Wickham/Grolemund (2017)](https://r4ds.had.co.nz/tidy-data.html).*
* [Yihui Xie, J. J. Allaire, Garrett Grolemund](https://bookdown.org/yihui/rmarkdown/)


##  Más sobre `tidyverse`

Lo que se intenta es hacer un diseño y  una gramática  que sea sencilla como una API para usuarios no "tecnólogos".

* Las `tibbles` como estructura de datos (superan a los `data.frames` y simplifican los `data.table`)

* El operador `%>%` para crear flujos de datos  y  funciones.

* Estandarizar la nomenclatura de las funciones,

* Establecer un orden razonable  en  los argumentos de las funciones (por ejemplo, `fn(argumento_A = datos, argumento_B = etiquetas de las columnas, ...)`.

##  Más sobre `tidyverse`

La sintaxis del `tidyverse` puede verse como un "dialecto" de `R`. 


```{r serpiente_camello, echo=FALSE,fig.align='center',out.width="40%"}
knitr::include_graphics("Imgs/serpiente_camello.png")
```

*Nota: Para más información*, véase [Tidyverse Team (2020)](https://design.tidyverse.org/) y [Wickham (2019)](https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html).




# Tidy data

## ¿Qué es tidy data?

Los conjuntos de datos ordenados son todos iguales; pero cada conjunto de datos desordenado es desordenado a su manera. [Wickham/Grolemund: r4ds](https://r4ds.had.co.nz/tidy-data.html)

Si tenemos datos provenientes de distintas fuentes, seguramente tendremos que estructurarlos en una única tibble.

**Principios de los datos estructurados:** 

El concepto de datos ordenados implica conjuntos de datos rectangulares y tabulares compuestos por filas y columnas:

1. Cada variable forma una columna.

2. Cada observación forma una fila.

3. Cada tipo de unidad de observación forma una tabla.

## ¿Qué es tidy data?

```{r tidydata, echo=FALSE,fig.align='center',out.width="60%"}
knitr::include_graphics("Imgs/tidy_data.PNG")
```

## Estructurar y ordenar datos (tidy)

**Violaciones de los principios de los datos ordenados:**

1. Las cabeceras de las columnas son valores, no nombres de variables.  

2. Se almacenan múltiples variables en una columna.  
3. Las variables se almacenan tanto en filas como en columnas.  

4. Se almacenan múltiples tipos de unidades de observación en la misma tabla. 

5. Una misma unidad de observación se almacena en varias tablas.

## Estructurar y ordenar datos

Veamos ejemplos de lo anterior con unos datos de  [pingüinos](https://allisonhorst.github.io/palmerpenguins/) con los que seguiremos trabajando luego.

```{r, warning=FALSE}
#install.packages("palmerpenguins",dep=TRUE)
library("palmerpenguins")
print(penguins, width = 50)
```


## Estructurar y ordenar datos (tidy)

```{r, echo=F, warning=F}
set.seed(123)

penguins %>% 
  group_by(species, island) %>% 
  summarise(n = n(), .groups = "drop") %>% 
  pivot_wider(names_from = island, values_from = n) %>% 
  unnest(cols = c(Biscoe, Dream, Torgersen))
```

```{r, echo=F}
penguins %>% 
  select(species, island, sex, year) %>% 
  unite(col, species, sex) %>% 
  sample_n(5)
```

```{r, echo=F, message=F, warning=F}
penguins %>% 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm) %>% 
  corrr::correlate(method = "pearson")
```

## Estructurar y ordenar datos (tidy)

```{r , echo=F,message=F, warning=F}
penguins %>% 
  select(species, island, sex) %>% 
  sample_n(3) %>% 
  bind_rows(
    mtcars %>%
      tibble::rownames_to_column("model") %>% 
      select(model, mpg, cyl) %>% 
      sample_n(3)
  )
```

```{r, echo=F, message=F, warning=F}
penguins %>% 
  select(species, island, sex) %>% 
  sample_n(3) %>% 
  bind_rows(
    mtcars %>%
      tibble::rownames_to_column("model") %>% 
      select(model, mpg, cyl) %>% 
      sample_n(3)
  )
```



## Estructurar y ordenar datos (tidy)


```{r plot_tidy, echo=F,fig.align="center",include=FALSE, out.width="30%"}
png("Imgs/plot_tidy.png")
set.seed(33)
x=rnorm(1000)
y=rnorm(1000)
colores=cut(x,4)
levels(colores)=c("red","blue","green","brown")
par(mfrow=c(1,2))
plot(x=x,y=y,pch=15,col=sample(c("red","blue","green","brown"),500,replace=TRUE),
axes=FALSE,xlab="",ylab="",main="Datos NO tidy")
plot(x=x,y=y,pch=15,col=as.character(colores),axes=FALSE,xlab="",ylab="",main="Datos tidy")
par(mfrow=c(1,1))
dev.off()
```


```{r tidy_data, echo=FALSE,fig.align='center',out.width="50%"}
knitr::include_graphics("Imgs/plot_tidy.png")
```


# Magrittr  pipes (tuberías)

## Datos de los pingüinos del Archipelago de Palmer (Antarctica) 

Como mencionamos antes, para  poner ejemplos  de los distintos paquetes de `tidyverse` utilizamos datos del paquete `palmerpenguins` de [Allison Horst](https://allisonhorst.github.io/palmerpenguins/).

El paquete incluye datos sobre los pingüinos observados en las islas del archipiélago Palmer, cerca de la estación Palmer, en la Antártida.


```{r, echo=F, fig.align='center', out.width='30%'}
knitr::include_graphics("Imgs/pinguinos_madagascar.jpg")
```


## Datos de los pingüinos

```{r, echo=F, fig.align='center', out.width='35%'}
knitr::include_graphics(c("Imgs/lter_penguins.png","Imgs/culmen_depth.png"))
```



## Operadores de "tuberías" para `R`

```{r,fig.align='right',out.width="5%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_pipe.png")
```

 Los operadores pipes de `magrittr` son:

* **Operador de tuberías:** `%>%`
* **Operador de asignación:** `%<>%`
* **Operador "T":** `%T>%`
* **Operador de extracción ("exposition"):** `%$%`.

**Ejemplo**
```{r, eval=FALSE}
rnorm(200) %>%
matrix(ncol = 2) %T>%
plot %>% # plot no suele retornar nada
colSums
```


## Operadores de "tuberías" para `R`
Estos operadores pretenden mejorar la legibilidad de los códigos de múltiples maneras:

* Organizando las operaciones en una cadena de instrucciones encadenadas (de izquierda a derecha) fácilmente legible,

* Evitando las llamadas a funciones anidadas, 

* Minimizando el uso de asignaciones de variables locales (`<-`) y definiciones de funciones, 

* Añadiendo y/o eliminando fácilmente pasos del "pipeline" sin romper el código.


El operador  %$% (pasa  las variables  de una tibble/data.frame.

```{r, message=FALSE, eval=FALSE}
library(magrittr)
iris %>%
  subset(Sepal.Length > mean(Sepal.Length)) %$%
  cor(Sepal.Length, Sepal.Width)
```

## Operadores de "tuberías" para `R`

```{r out.width="50%", fig.align='center'}
data.frame(z = rnorm(100)) %$%  ts.plot(z)
```



## El operador  pipe 

**pipes básicos:** pasan un valor, atributo  u objeto (LHS: Left Hand Side ) a la siguiente llamada de función (RHS: Right Hand Side) como **primer** argumento
<br>

```{r, eval=F}
x %>% f # equivalente a: f(x)
x %>% f(y) # equivalente a: f(x, y)
x %>% f %>% g %>% h # equivalente a: h(g(f(x)))
```

## El operador  pipe

**pipes con marcadores de posición:** reenvian un valor u objeto (LHS) a la siguiente llamada de función (RHS) como **cualquier** argumento


```{r, eval=F}
x %>% f(.) # equivalente a: x %>% f
x %>% f(y, .) # equivalente a: f(y, x)
x %>% f(y, z = .) # equivalente a: f(y, z = x)
x %>% f(y = nrow(.),
        z = ncol(.))  # equivalente a: f(x, y = nrow(x), z = ncol(x))
```


## Construcción de funciones con pipes

Una secuencia de código que comienza con el marcador de posición (`.`) devuelve una función que puede utilizarse para aplicar posteriormente la tubería a valores concretos


```{r, eval=F}
f <- . %>% cos %>% sin # equivalente a: f <- function(.) sin(cos(.))
```
```{r, eval=F}
f(20) # equivalente a: la tubería 20 %>% cos %>% sin
```

 
\blue{Nota: Para saber más sobre} `%>%`, haced `vignette("magrittr")` en la consola de R.


\red{Se puede obtener la cadena}  `%>%`  en Rstudio desktop utilizando el atajo de teclado: 


\red{Ctrl + Shift  + M}.

## Ejemplo con el operador pipe

**Pregunta:** ¿Cuál es la masa corporal media en gramos de todos los pingüinos observados en el año 2007 (tras excluir los valores perdidos)?

**En un mundo sin pipes:**
```{r, eval=F}
mean(subset(penguins, year == 2007)$body_mass_g, na.rm = T)

# alternativamente:
peng_bm_2007 <- subset(penguins, año == 2007)$body_mass_g
media(peng_bm_2007, na.rm = T)
```

**En un mundo con pipes:**
```{r, eval=F}
penguins %>% 
  subset(año == 2007) %>% 
  .$body_mass_g %>% 
  mean(na.rm = T)
```

## Ventajas de usar pipes

* El estilo secuencial  de las  tuberías mejora la legibilidad y la lectura que las funciones anidadas.

* Hace innecesario almacenar los resultados intermedios.

* Es muy fácil añadir  o eliminar pasos (empalmes de tuberías) individuales en el "pipe-line/canalización"

\

Las versiones recientes de R ya tiene viene con un operador de tuberías nativo también (`|>`).

## El pipe de R base

```{r}
mtcars |> head()  #  es lo mismo que head(mtcars)
mtcars |> head(2) #  es lo mismo que  head(mtcars, 2)
mtcars |> subset(cyl == 4) |> nrow()  
```


## Pipes avanzadas

Los empalmes de tuberías más avanzados como la `%T%` nos permiten economizar lineas de código.

* `%T>%` se puede utilizar para activar el efecto secundario de una función, por ejemplo, para imprimir salidas, y dejar que los datos originales pasen por alto el paso respectivo.

```{r}
penguins[1:5, c("island", "bill_length_mm" )] %T>% 
  print %>% .$"bill_length_mm"  %>%
  mean(na.rm=T)
```
## Tuberías avanzadas


* El operador `%$%` extrae las variables del objeto LHS a la expresión RHS. Es equivalente a:
```{r, eval=FALSE}
plot(penguins$species, penguins$bill_length_mm)
```

```{r, fig.width=6, fig.asp=0.618, fig.retina=3,out.width="50%", fig.align='center'}
penguins %$% 
  plot(species,bill_length_mm) 
# 
```
 
## Tuberías avanzadas

El operador `%<>%` se puede utilizar de forma equivalente al operador de asignación de base `R` (`<-`). 


```{r, results='asis'}
variable <- penguins$bill_length_mm
variable %<>% mean(na.rm=T)
variable
```


# Paquete tibble


## Data frame avanzado: tibble

EL paquete `tibble` proporciona un objeto de tipo data frame mejorado: `tbl_df`. Un `tibble` se puede crear de cuatro maneras diferentes.


1. A partir de vectores columna con `tibble()`.

```{r}
tibble(
  x = c("a", "b"),
  y = c(1, 2),
  z = c(T, F)
)
```

## Data frame avanzado: tibble

2. Escribiendo  en texto por columnas `tibble`,  fila por fila con `tribble()`.

```{r}
tribble(
  ~x, ~y, ~z,
  "a", 1, T,
  "b", 2, F
)
```
## Data frame avanzado: tibble

3. Creando un `tibble` a partir de otro objeto  de las clases `matrix` o `data.frame`  con  `as_tibble()`.

```{r}
data.frame(
  x = c("a", "b"),
  y = c(1, 2),
  z = c(T, F)
) %>% 
as_tibble
```
## Data frame avanzado: tibble

4. Creando un `tibble` a partir de vectores con nombre con `enframe()`.

```{r}
c(x = "a", y = "b", z = 1) %>%
  enframe(name = "x", value = "y")
```
## Data frame avanzado tibble

\red{Diferencias entre tibble y data.frame}

* Un tibble nunca cambia el tipo de entrada.
  - Ya no hay que preocuparse de que los caracteres se conviertan automáticamente en cadenas.
  
* Un tibble puede tener columnas que son listas.

* Un tibble puede tener nombres de variables no estándar.
  - Pueden  empezar por  un número o contener espacios.
  - Para utilizarlo se refiere a estos en un backtick: `peso en Kg`.
  
* Sólo recicla vectores de longitud 1.

* No tiene como atributo nombres de filas `row.names`.

## Data frame avanzado tibble

**Impresión:** Por defecto, `tibble()` imprime sólo las diez primeras filas y todas las columnas que caben en la pantalla, y las clases de las columnas

```{r}
penguins
```


## Data frame avanzado: tibble

Aquí se ve la diferencia con la clase `data.frame`.

```{r}
data.frame(penguins)
```


## Data frame avanzado: tibble

**`glimpse`** nos da la versión transpuesta de `print()`.

\

```{r}
penguins %>% glimpse
```


## Data frame avanzado: tibble

**Subconjunto:** El subconjunto de un `tibble` (`[]`) siempre devuelve otro `tibble` y nunca un vector (en contraste con los objetos estándar `data.frame`).


```{r}
data.frame(penguins) %>% .[, "species"] %>% class
```


```{r}
penguins[, "species"] %>% class
```


## Data frame avanzado: tibble

El subconjunto de un data.frame  busca el nombre de variable más parecido

```{r}
names(data.frame(penguins))
head(data.frame(penguins)$spec)
```

\red{`tibble` no permite la coincidencia parcial, es decir, siempre se debe proporcionar el nombre completo de la columna.}

## Data frame avanzado: tibble

```{r}
head(penguins$spec)
```

```{r}
head(penguins$species)
```


* Las tibbles dan mejores mensajes `Warning` y `Error` para solucionar problemas.


<!-- * `readr` no lee  datos en formatos que no sean texto, sino almacenados en un archivo de texto (txt, csv, excel) -->



## Leer datos de texto rectangulares `readr` 

El paquete **`readr`** proporciona funciones de lectura y escritura para múltiples formatos de archivo diferentes:

* `read_delim()`: archivos delimitados en general

* `read_csv()`: archivos separados por comas

* `read_csv2()`: archivos separados por punto y coma. En la mayoría de los países europeos, Microsoft Excel utiliza `;` como delimitador común

* `read_tsv()`: archivos separados por tabulaciones

* `read_fwf()`: archivos de ancho fijo

* `read_table()`: archivos separados por espacios en blanco

* `read_log()`: archivos de registro web

## Leer datos de texto rectangulares `readr`

* Convenientemente, las funciones `write_*()` funcionan de forma análoga. 

* Se utiliza el paquete `readxl` para archivos de Excel,

* El paquete `haven` para archivos de Stata, SAS y SPSS,

* El paquete `googlesheets4` para Google Sheets 

* El paquete `rvest` para archivos HTML. Paquete de referencia en el contexto de la extracción de datos de la web con `R` 


## Leer datos de texto rectangulares `readr` 

Para ilustrar el paquete `readr`, a priori, hemos escrito un archivo csv que contiene los datos de los pingüinos, utilizando  `write_csv(penguins, archivo = "datos/penguins.csv")`.


```{r}
data <- read_csv(file = "data/penguins.csv")
```


```{r}
data <- read_csv(file = "data/penguins.csv", col_select = c(species, island))
```

## Leer datos de texto rectangulares `readr` 

```{r}
data <- read_csv(file = "./data/penguins.csv",
                 col_names = paste("Var", 1:8, sep = "_"))
```

## Leer datos de texto rectangulares `readr` 

```{r}
data <- read_csv(file = "./data/penguins.csv", skip = 5)
```

\

\red{Observa que} la salida de cualquier función `read_*()` es un objeto `tibble`.

## Leer datos de texto rectangulares `readr` 

* `readr` imprime las especificaciones de las columnas después de la importación. 

* Por defecto, `readr` intenta inferir el tipo de columna (por ejemplo, `int`, `dbl`, `chr`, `fct`, `date`, `lgl`) a partir de las primeras 1.000 filas y analiza las columnas en consecuencia.

* Intenta hacer explícitas las especificaciones de las columnas. Es probable que te familiarices más con tus datos y veas advertencias si algo cambia inesperadamente.

## Leer datos de texto rectangulares `readr` 

```{r, eval=F}
read_csv(
  archivo = "./data/penguins.csv",
  col_types = cols(
    species = col_character(),
    año = col_datetime(formato = "%Y"),
    isla = col_skip())
  )
```


## Leer datos de texto rectangulares `readr` 

Analizar sólo las primeras 1.000 filas es eficiente, pero puede llevar a conjeturas erróneas:

```{r, eval=F}
read_csv(file = "./data/penguins.csv", guess_max = 2000)
```


\blue{Nota}: Encuentra más información y funciones de `readr` en  [hoja de trucos](https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-import.pdf).


\

A veces puedes tener problemas al leer datos de texto (tipo carácter): los signos especiales como ö, ä o ü pueden ser codificados de forma extraña como símbolos crípticos.  En esos casos debes controlar la codificación los datos en la función read_csv (por ejemplo, UTF-8)



## Leer datos de texto rectangulares `readr` 

Supongamos que deseas dejar de utilizar los archivos `.xlsx` y `.csv` ya que no son capaces de almacenar de forma fiable los metadatos (por ejemplo, los tipos de datos).


Las funciones `write_rds()` y `read_rds()` (son warppers de `writeRDS` y `readRDS` del paquete base de R) proporcionan una buena alternativa para [serializar](https://en.wikipedia.org/wiki/Serialization) tus objetos `R` (por ejemplo, `tibbles`, modelos) y almacenarlos como archivos `.rds`.

Más info sobre [archivos rds](https://mgimond.github.io/ES218/Week02b.html#Export_to_a_Rds_file)

## Leer datos de texto rectangulares `readr` 
```{r}
penguins %>% 
  write_rds(file = "./data/penguins.rds")
```

```{r}
penguins <- read_rds(file = "./data/penguins.rds")
```

<br>

Nota que:

* `write_rds()` solo puede utilizarse para guardar un objeto a la vez,

* un archivo `.rds` cargado debe ser almacenado en una nueva variable, es decir, darle un nuevo nombre,

* `read_rds()` ¡conserva los tipos de datos!


# Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="5%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png") 
``` 

**`tidyr`** proporciona varias funciones que nos ayudarán a convertir nuestros datos en  *"tidy data"* format (p.e., reestructurarlos, dividir las columnas, manejar los datos perdidos o agruparlos). De nuevo, utilizaremos los datos de los pingüinos.

```{r}
penguins
```

---

## Tidyr: Ordenar datos desordenados: `tidyr`

**Pivotting:** Cambiar el formato entre largo y ancho de una tabla de datos con las funciones: `pivot_longer()` y `pivot_wider()`.

```{r, out.width="50%",fig.align='center',echo=FALSE}
knitr::include_graphics("Imgs/pivotting.png") 
```

---

En nuestro ejemplo:

```{r}
long_penguins <- penguins %>% 
  pivot_longer(
    cols = c(species, island),
    names_to = "variable", values_to = "valor"
  )

long_penguins %>% glimpse

```

Ya no hay formato ordenado. La dim: 688 x 8

---
`pivot_wider()`:

- invierte en efecto de  `pivot_longer()`

- dim: 344 x 8


```{r}
long_penguins %>% 
  pivot_wider(
    names_from = "variable", values_from = "valor"
  ) %>%
glimpse
```

Puedes encontrar más información acerca de `pivot_*()` en [pivoting vignette](https://tidyr.tidyverse.org/articles/pivot.html).


## Tidyr: Ordenar datos desordenados: `tidyr`

**Nesting:** Agrupa datos similares de manera que cada grupo se convierte en una sola fila en un data frame.

```{r}
nested_penguins <- penguins %>% 
    nest(nested_data = 
           c(island, bill_length_mm, 
             bill_depth_mm,flipper_length_mm,
             body_mass_g, sex))
nested_penguins
```
## Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="5%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png") 
```

- La función `nest()` genera datos anidados en un data frame con una fila por `species` y `year`.


- Los datos anidados `nested_data` por columnas contienen `tibbles` con seis columnas cada uno y  un  número de observaciones que pueden ser distintas.


- Los datos anidados son útiles si queremos aplicar funciones a cada subgrupo  de datos  (por ejemplo, comparar  estadísticos por especie.)

## Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="5%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png") 
```
**Rectangling:** Deshace las estructuras de datos anidados (por ejemplo, JSON, HTML) y las lleva al formato de *datos ordenados*.


Extrae objetos individuales de una estructura de datos anidada mediante `purrr::pluck()`.
```{r}
nested_penguins %>% purrr::pluck("nested_data", 1)
```
## Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="5%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png") 
```
Aplana las estructuras de datos anidados mediante `tidyr::unnest()`.

```{r}
nested_penguins %>% unnest(cols = c(nested_data)) 
```

## Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="3%",fig.align='right',echo=FALSE,eval=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png")
```
Extraer selectivamente componentes individuales de un objeto en una estructura de datos anidada mediante `tidyr::hoist()`.

```{r}
nested_penguins %>% hoist(nested_data, hoisted_col = "bill_length_mm")
```




Alternativamente, utilice `unnest_wider()` o `unnest_longer()` para tener más control sobre la operación de rectangulación.



## Tidyr: Ordenar datos desordenados: `tidyr`
**Dividir** y **Combinar:** 
Combina múltiples columnas en una sola columna.

```{r}
penguins %>% unite(col = "specie_sex",
                   c(species, sex), sep = "_", remove = T)
```


## Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="5%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png") 
```
Separar una sola columna, que contiene varios valores, en varias columnas.
```{r}
penguins %>% separate(bill_length_mm, sep = 2, into = c("cm", "mm"))
```



## Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="3%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png") 
```
Separar una sola columna, que contiene varios valores, en varias filas.
```{r}
penguins %>% separate_rows(island, sep = "s", convert = T)
```

Podemos `separar` basándonos en la coincidencia de caracteres



## Tidyr: Ordenar datos desordenados: `tidyr`

**Manejo de los valores perdidos:** Elimina o sustituye los valores perdidos (`NA`).

Supongamos que tenemos una tibble y queremos hacer explícitos los valores perdidos implícitos.

```{r, echo=F}
incompl_penguins <- tibble(
  species = c(rep("Adelie", 2), rep("Gentoo", 1), rep("Chinstrap", 1)),
  year = c(2007, 2008, 2008, 2007),
  measurement = c(rnorm(3, mean = 50, sd = 15), NA)
)
```

```{r}
incompl_penguins
```


## Tidyr: Ordenar datos desordenados: `tidyr`

Para hacer explícitos los NAs implícitos:

```{r}
incompl_penguins %>% 
  complete(species, year, fill = list(measurement = NA))
```


## Tidyr: Ordenar datos desordenados: `tidyr`

Para hacer implícitos los valores perdidos explícitos.
```{r}
incompl_penguins %>% 
  drop_na(measurement)
```



## Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="5%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png") 
```
Reemplaza los valores que faltan por el valor siguiente/anterior.
```{r}
incompl_penguins %>% 
  fill(measurement, .direction = "down")
```

## Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="5%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png") 
```
Reemplaza los valores que faltan por un valor predefinido.
```{r}
incompl_penguins %>%
  replace_na(replace = list(measurement = mean(.$measurement, na.rm = T)))
```

## Tidyr: Ordenar datos desordenados: `tidyr`
```{r, out.width="5%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_tidyr.png") 
```

[Más   información en `tidyr` cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-import.pdf).


Nota: los argumentos de función precedidos por un punto en el tidyverse pueden tener una de estas dos razones:

- la función es todavía prematura, es decir, los desarrolladores aún piensan en la mejor manera de implementar y nombrar la función

- la función se aplica regularmente dentro de otra función para no confundir los argumentos de la función entre la función interna y la externa

# `dplyr`: Una gramática para manipular datos

## `dplyr`: Una gramática para manipular datos

`dplyr` proporciona un conjunto de funciones para manipular objetos de data frames (por ejemplo, `tibbles`), basándose en una gramática consistente.

Las funciones están representadas intuitivamente por "verbos" que reflejan las operaciones subyacentes y siempre dan como resultado un `tibble` nuevo o modificado.

**Operaciones sobre las filas**

- `filter()` selecciona las filas que cumplen uno o varios criterios lógicos

- `slice()` selecciona las filas en función de su ubicación en los datos

- `arrange()` cambia el orden de las filas

## Ejemplos con `filter()`
* Filtrar todos los pingüinos de la `especie` "Adelie".

```{r}
penguins %>% 
  filter(species == "Adelie")
```

## Ejemplos con `filter()`

* Filtrar todos los pingüinos con un valor perdido en la variable `bill_length_mm`.
\

```{r}
penguins %>% 
  filter(is.na(bill_length_mm) == T)
  # quitar los Nas
  #filter(!is.na(bill_length_mm) == F)
```

## Ejemplos con `filter()`

* Filtrar todos los pingüinos observados antes del año 2008 o después del año 2008 y en los que la masa corporal está entre 3800 y 4000 gramos.
\

```{r}
penguins %>% 
  filter(between(body_mass_g, 3800, 4000) & (year < 2008 | year > 2008))
```

<!-- \ -->

<!-- \red{Nota}: -->
<!--  Ten en cuenta que usar `=` en lugar de `==` es un error común (`<-` = `=`). -->
 
## Ejemplos con `slice()`

 * Elegir las filas de acuerdo a su índice.
 \
```{r}
penguins %>% 
  slice(23:27)
```


## Ejemplos con `slice()`

* `slice_head()` selecciona las primeras `n` filas (viceversa para `slice_tail()`).

```{r}
penguins %>% 
  slice_head(n = 5) 
# alternativamente: 
#slice_head(frac = 0.05)
```

## Ejemplos con `slice()`

* Selecciona una muestra aleatoria de `n` filas (con o sin reemplazo).


```{r}
penguins %>% 
  slice_sample(n = 5)
```

## Ejemplos con `slice()`

* Selecciona las `n` filas con el valor más grande (viceversa para `slice_min()`).

```{r}
penguins %>% 
  slice_max(bill_length_mm, n = 5)
```

## Ejemplos con `arrange()`

* Selecciona los cinco pingüinos con menor masa corporal.

```{r}
penguins %>% 
  arrange(body_mass_g) %>% 
  slice_head(n = 5)  # equivalentente a: slice_min(body_mass_g, n = 3)
```

* ¿Cómo seleccionarías a los 5 pingüinos con mayor masa corporal? 

## `dplyr`: Una gramática para manipular datos

```{r, out.width="10%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_dplyr.PNG") 
```

**Operaciones sobre las columnas**

- `select()` selecciona o elimina determinadas columnas

- `rename()` cambia los nombres de las columnas

- `relocate()` cambia el orden de las columnas

- `mutate()` transforma los valores de las columnas y/o crea nuevas columnas

## Ejemplos `select()`

* Selección por índice

```{r}
penguins %>% 
  select(1:3) %>% 
  glimpse
```

## Ejemplos `select()`

* Selección por nombre
\

```{r}
penguins %>% 
  select(species, island, bill_length_mm) %>% 
  glimpse
```

## Ejemplos `select()`
* Seleccionar todas las columnas
```{r}
penguins %>% 
  select(everything()) %>% 
  glimpse

# select(last_col())
```

## Ejemplos `select()`

* Seleccionar las columnas cuyos nombres empiezan por un patrón específico
\
```{r}
penguins %>% 
  select(starts_with("bill")) %>% 
  glimpse
# ends_with()
```

## Ejemplos `select()`

```{r}
penguins %>% 
  select(contains("e") & contains("a")) %>% 
  glimpse
```

## Ejemplos `select()`

Seleccionar columnas en base a una expresión regular ([regex](https://www.rexegg.com/regex-quickstart.html))

```{r}
penguins %>% 
  select(matches("_\\w*_mm$")) %>% 
  glimpse
```

## Ejemplos `select()`

```{r}
penguins %>% 
  select(where(is.numeric)) %>% 
  glimpse
```

## Ejemplos `select()`

¿Qué columnas devuelven las siguientes consultas?

```{r, eval=F}
penguins %>% 
  select(ends_with("mm"))
```

```{r, eval=F}
penguins %>% 
  select(-contains("mm"))
```

```{r, eval=F}
penguins %>% 
  select(where(~ is.numeric(.))) %>%  # select(where(is.numeric))
  select(where(~ mean(., na.rm = T) > 1000))
```

## Ejemplos `rename()`

* Cambiar el nombre de la columna `body_mass_g` (`sex`) a `bm` (`gender`).

```{r}
penguins %>% rename(bm = body_mass_g, gender = sex) %>% 
  colnames()
```

* Cambiar los nombres de las columnas que incluyen `"mm"` a mayúsculas.

```{r}
penguins %>% rename_with(.fn = toupper, .cols = contains("mm")) %>% 
  colnames()
```

## Ejemplos `relocate()`

* Cambiar el orden de las columnas en la `tibble` de acuerdo al siguiente esquema:

1. colocar "especie" después de "masa corporal".
2. colocar "sexo" antes de "especie".
3. colocar "isla" al final

```{r}
penguins %>% 
  relocate(species, .after = body_mass_g) %>%
  relocate(sex, .before = species) %>%
  relocate(island, .after = last_col()) %>%
  colnames()
```

## Ejemplos `mutate()`

Crear una nueva variable `bm_kg` que ponga `body_mass_g` en kilogramos.

```{r}
penguins %>% 
  mutate(bm_kg = body_mass_g / 1000, .keep = "all", .after = island) %>% 
  slice_head(n = 5)
```

- Usa `.keep` para especificar las columnas que se mantendrán después de la manipulación.
- Usa `.before`/`.after` para especificar la posición de la nueva columna.
- Para anular una columna dada simplemente utiliza el mismo nombre de columna.
- Para mantener sólo la nueva columna utiliza `dplyr::transmute()`.

## Ejemplos `mutate()`

Codificación de una variable categórica con "C" niveles de factor en "C" dummies (a menudo en la modelización se crean "C-1" dummies).

```{r}
penguins %>% 
  mutate(
    sex_binary = case_when(
      sex == "male" ~ 1,
      sex == "female" ~ 0),
    .keep = "all", .after = island
  ) %>% 
  slice_head(n = 3)
```


## Ejemplos `mutate()`
`case_when`:
  - Versión vectorizada de if_else
  
  - Fórmulas de dos lados: El LHS comprueba la condición, el RHS especifica el valor de sustitución
  
  - Para los casos no coincidentes, la función devuelve NA
  
  - Utiliza el LHS `TRUE` para capturar todos los casos no especificados explícitamente de antemano

## Ejemplos `mutate()`

* Transforma las variables de medidas a metros

```{r}
penguins %>% 
  mutate(
    across(contains("mm"), ~ . / 1000),
    .keep = "all"
  ) %>% 
  slice_head(n = 3)
```

## Ejemplos `mutate()`

`across`:

- Aplicar la misma transformación en varias columnas

- Te permite utilizar la semántica que conoces de la función `select()`.

- No requiere que se especifique explícitamente un nombre de columna, ya que sólo transforma las columnas existentes

## Ejemplos `mutate()`
* Define `species`, `island` y `sex` como variables categóricas, es decir *factores*, usando `across()`.
\

```{r}
penguins %>% 
  mutate(
    across(where(is.character), as.factor),
    .keep = "all"
  ) %>% 
  slice_head(n = 3)
```

## `dplyr`:Una gramática para manipular datos

```{r, out.width="10%",fig.align='right',echo=FALSE}
knitr::include_graphics("Imgs/logo_dplyr.PNG") 
```
**Operaciones sobre datos agrupados**

- `group_by()` divide los datos en función de una o varias columnas

- `summarise()` reduce un grupo de datos en una sola fila

## Ejemplos `group_by`

* Partición de los datos en una o varias columnas

```{r}
penguins %>% group_by(species)
```

Utiliza `group_keys()`, `group_indices()` y `group_vars()` para acceder a las claves de agrupación, los índices de grupo por fila y las variables de agrupación. 

## Ejemplos `group_by`

`group_by()` cambia la representación del `tibble` y lo transforma en un data frame agrupado (`grouped_df`). 

Esto nos permite operar en los subgrupos individualmente usando `summarise()`.

`summarise()` reduce un grupo de datos en una sola fila

## Ejemplos `group_by`

```{r}
penguins %>% group_by(species) %>% 
  summarise(count = n(), .groups = "drop")
```


## Ejemplos `summarise()`

```{r}
penguins %>% group_by(species, sex) %>% summarise(count = n(), .groups = "drop")
```

## Ejemplos `summarise()`
```{r}
penguins %>%
  group_by(species) %>%
  summarise(
    across(contains("mm"), ~ mean(., na.rm = T), .names = "{.col}_avg"),
    .groups = "drop"
  )
```

El uso de `group_by()`, seguido de `summarise()` y `ungroup()` refleja el paradigma **dividir-aplicar-combinar** del análisis de datos: Dividir los datos en particiones, aplicar alguna función a los datos y luego combinar los resultados.

## Ejemplos `summarise()`
*Nota: En lugar de utilizar `ungroup()` puedes poner el argumento `.groups` en `summarise()` igual a "drop".*

Utiliza `.add = T` para añadir nuevas variables de agrupación (si no, se anula la primera)

```{r}
penguins %>% 
  group_by(species) %>% 
  group_by(year, .add = T)   # equivalente a: group_by(species, year)
```

## Ejemplos `summarise()`
```{r}
penguins %>%
  group_by(species) %>%
  summarise(
    across(
      contains("mm"),
      list(avg = ~ mean(., na.rm = T), sd = ~ sd(., na.rm = T)),
      .names = "{.col}_{.fn}"
    ),
    .groups = "drop"
  )
```

## Ejemplos `summarise()`

**Cambios en el comportamiento de `mutate()`:** Las funciones de resumen, por ejemplo, `mean()` o `sd()` operan en particiones de los datos en lugar de en los datos completos

```{r}
penguins %>%
  group_by(species) %>% 
  mutate(stand_bm = (body_mass_g - mean(body_mass_g, na.rm = T))
         / sd(body_mass_g, na.rm = T)) %>% 
  glimpse
```

## Ejemplos `summarise()`

* Calcular franjas para la masa corporal de acuerdo a la cantidad de desviaciones estándar de la media. Agrupar los datos según estos intervalos.

```{r, eval=FALSE}
bm_breaks <- mean(penguins$body_mass_g, 
                  na.rm = T) - (-3:3) *
  sd(penguins$body_mass_g,na.rm = T)

penguins %>% 
  group_by(species, bm_bin = cut(body_mass_g, breaks = bm_breaks)) %>%
  summarise(count = n(), .groups = "drop")
```

## Ejemplos `summarise()`

```{r, echo=FALSE}
bm_breaks <- mean(penguins$body_mass_g, 
                  na.rm = T) - (-3:3) *
  sd(penguins$body_mass_g,na.rm = T)

penguins %>% 
  group_by(species, bm_bin = cut(body_mass_g, breaks = bm_breaks)) %>%
  summarise(count = n(), .groups = "drop")
```

## Ejemplos `summarise()`

* Filtrar en las particiones en lugar de en la totalidad de los datos

```{r}
penguins %>% 
  group_by(species, island) %>% 
  filter(flipper_length_mm == max(flipper_length_mm, na.rm = T))
```

## Ejemplos `summarise()`

* Utilizar `group_by()` seguido de `nest()` para producir un data frame anidado

```{r}
penguins %>% 
  group_by(species, year) %>% 
  tidyr::nest()
```

Puedes encontrar más información de `group_by()` ejecutando `vignette("grouping")`.

## `dplyr`: Una gramática para manipular datos
**Otras operaciones con `dlpyr`**

`distinct()` selecciona sólo filas únicas
```{r}
penguins %>% 
  distinct(species, island)
```

`pull()` extrae columnas individuales como vectores

```{r, eval=FALSE}
penguins %>% 
  pull(year)  # equivalente a: penguins$year
```

## `dplyr`: Una gramática para manipular datos
`if_else()` sentencia if-else vectorizada.
```{r}
penguins %>% select(species, island, body_mass_g) %>% 
  mutate(penguin_size = if_else(body_mass_g < 3500,
                                "tiny penguin",
                                "big penguin"))
```

## `dplyr`: Una gramática para manipular datos

`lag()` desplaza los valores de las columnas `n` hacia adelante

```{r}
penguins %>% select(species, body_mass_g) %>% 
  mutate(lagged_bm = lag(body_mass_g, n = 1))
```
Lo utilizaremos cuando estudiemos series temporales

## `dplyr`: Una gramática para manipular datos
Combinar diferentes data frames haciendo coincidir las filas en función de las claves (de forma similar a las uniones realizadas en SQL)

```{r, out.width="40%",fig.align='center',echo=FALSE}
knitr::include_graphics("Imgs/combinar_tablas.PNG") 
```

## Visualizar los `pipes`

En el enlace de [Tidydatatutor](https://tidydatatutor.com/) puedes escribir código R y Tidyverse en tu navegador y ver cómo cambia el data frame en cada paso del pipeline que has escrito.

Aquí os dejo el enlace para visualizar las  instrucciones más utilizadas de tidyverse con el ejemplo de los pingüinos:

* [arrange()](https://tidydatatutor.com/vis.html#trace=example-code/r_arrange.json).

* [filter()](https://tidydatatutor.com/vis.html#trace=example-code/r_filter.json)


* [mutate()](https://tidydatatutor.com/vis.html#trace=example-code/r_mutate.json)

* [select()](https://tidydatatutor.com/vis.html#trace=example-code/r_select.json)

* [group_by() %>%  slice()](https://tidydatatutor.com/vis.html#trace=example-code/r_grouped_slice.json)

* [group_by() %>% summarize()](https://tidydatatutor.com/vis.html#trace=example-code/r_grouped_summarise.json)



# Visualización de datos con `ggplot2`

```{r, echo=F, out.height='30%', out.width='30%', fig.align='center'}
knitr::include_graphics("Imgs/ggplot2.PNG")
```

`ggplot2` es un sistema para crear gráficos de forma declarativa, basado en [The Grammar of Graphics](https://link.springer.com/chapter/10.1007/978-3-642-21551-3_13). Permite producir "**gráficos elegantes para el análisis de datos**"

La sintaxis de ggplot2 ayuda a pensar en
gráficos de una manera nueva y más general que R base. Facilita generar detalles importantes de los gráficos como las leyendas, los ejes, los colores, son fáciles de resolver en comparación con R base.

En [R gallery](https://r-graph-gallery.com/), [R charts](https://r-charts.com) y en [ggplot2 extensions](https://exts.ggplot2.tidyverse.org/gallery/) puedes encontrar muchos ejemplos de gráficos con los códigos.


## Gramática básica de `ggplot2`

**Un ggplot necesita al menos tres cosas que hay que especificar: ** 

* **Datos**: Normalmente un `tibble` del que se seleccionan las variables a visualizar. Siempre empezamos con **`ggplot(data = df)`** que le dice a `{ggplot2}` que vamos a trabajar con los datos `df`. 

* **Estética**: Propiedades visuales que deseamos tenga nuestro gráfico. Por ejemplo, si deseamos visualizar la relación entre dos variables de `df`: `var1` en el eje `x`  y `var2` en el eje `y`, debemos especificar: **`aes(x = var1, y = var2)`**. 

* **Geometría**: Forma geométrica que deseamos utilizar para representar los datos: puntos, líneas continuas, curvas, entre otras. Se especifica con **`geom_*()`**. Por ejemplo, `geom_point()` para hacer un diagrama de puntos.

## Ejemplo con la gramática básica

```{r, out.height='60%', out.width='60%', fig.align='center', message=FALSE}
penguins %>% 
  ggplot(aes(x=bill_length_mm, y = flipper_length_mm)) +
  geom_point(na.rm = TRUE)
```
 
## Más elementos de la gramática ... 

* **Escalas**: Permiten anular los valores por defecto de una estética para especificar otros. La sintáxis es **`scale_*()`**. Existen escalas para asignar valores de manera discreta, continua o manual. También escalas de localización, para color, relleno; tamaño y figuras. 

```{r, echo=F, out.height='60%', out.width='70%', fig.align='center'}
knitr::include_graphics("Imgs/escalas.PNG")
```

## Más elementos de la gramática ...

*	**Resúmenes (Stats)**: Permiten construir nuevas variables de resumen para hacer un gráfico. Por ejemplo: conteo, cuantiles, proporciones, curvas ajustadas. Se especifica con **`stat_*()`**. 

```{r, echo=F, out.height='60%', out.width='70%', fig.align='center'}
knitr::include_graphics("Imgs/stats.PNG")
```

## Más elementos de la gramática ...

* **Sistema de coordenadas**: Permite especificar cómo deseamos las coordenadas del gráfico. La sintáxis es **`coord_*`**.

```{r, echo=F, out.height='50%', out.width='40%', fig.align='center'}
knitr::include_graphics("Imgs/coordenadas.PNG")
```

## Más elementos de la gramática ...

* **Facetas**: Dividen una gráfica en múltiple subgráficas en base a una o varias variables discretas. La sintáxis es **`facet_*`**.

```{r, echo=F, out.height='50%', out.width='40%', fig.align='center'}
knitr::include_graphics("Imgs/facetas.PNG")
```

## Más elementos de la gramática ... 

*	**Ajuste de las posiciones**: Permite indicar qué hacer con geoms que ocuparían la misma posición en la gráfica

```{r, echo=F, out.height='50%', out.width='40%', fig.align='center'}
knitr::include_graphics("Imgs/posicion.PNG")
```

## Más elementos de la gramática ... 

* **Tema**: Valores visuales generales de un gráfico, como el fondo, las cuadrículas, los ejes, el tipo de letra predeterminado, los tamaños y los colores.

```{r, echo=F, out.height='40%', out.width='40%', fig.align='center'}
knitr::include_graphics("Imgs/temas.PNG")
```


## Visualizando una variable cualitativa nominal

Vamos a visualizar una variable cualitativa nominal, con un tema que no es el que trae por defecto ggplot con fondo gris

```{r, eval=FALSE}
penguins %>% 
  ggplot(aes(x = species)) +
  geom_bar(fill="blue") + 
  labs(x="Especie", y="Número de pingüinos") +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold")) 
```

## Visualizando una variable cualitativa 

```{r, out.height='60%', out.width='60%', fig.align='center', message=FALSE, echo=FALSE}
penguins %>% 
  ggplot(aes(x = species)) +
  geom_bar(fill="blue") + 
  labs(x="Especie", y="Número de pingüinos") +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"))
  
```


## Cruzando dos variables cualitativas 

Para observar la distribución conjunta de dos variables cualitativas hay que mapearlas a diferentes aspectos gráficos. 

```{r, eval=FALSE}
penguins %>% ggplot() + 
  geom_bar(aes(species, fill=island),
           position="dodge") + coord_flip() +
  guides(fill = guide_legend(title = "Isla")) +
  labs(x="Número de pingüinos", y="Especie") +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"),
        legend.title = element_text(size=20)) 
  
```

## Cruzando dos variables cualitativas 

```{r, out.height='60%', out.width='60%', fig.align='center', message=FALSE, echo=FALSE}
penguins %>% ggplot() + 
  geom_bar(aes(species, fill=island),
           position="dodge") + coord_flip() +
  guides(fill = guide_legend(title = "Isla")) +
  labs(y="Número de pingüinos", x="Especie") +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"),
        legend.title = element_text(size=20)) 
  
```

## Visualizando una variable cualitativa 

Para conseguir que cada barra represente el 100% de la categoría, se indica en el argumento de geom_bar.

```{r, out.height='60%', out.width='60%', fig.align='center', message=FALSE, echo=FALSE}
penguins %>% ggplot() + 
  geom_bar(aes(species, fill=island),
           position="fill") + coord_flip() +
  guides(fill = guide_legend(title = "Isla")) +
  labs(y="Proporción de pingüinos", x="Especie") +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"),
        legend.title = element_text(size=20))
```


## Visualizando una variable cuantitativa

```{r, out.height='40%', out.width='60%', fig.align='center', message=FALSE}
penguins %>% 
  ggplot(aes(x = flipper_length_mm)) +
  geom_histogram(na.rm = TRUE) +
    labs(x="Longitud de la aleta en mm", 
         y="Frecuencia absoluta") + 
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"))
```

## Cruzando una variable cuantitativa con una cualitativa


```{r, eval=FALSE}
ggplot(data = penguins, aes(x = flipper_length_mm)) +
  geom_histogram(aes(fill = species), 
                 alpha = 0.5, 
                 position = "identity",
                 na.rm = TRUE) +
  scale_fill_manual(values = c("darkorange","purple","cyan4")) +
  labs(x = "Longitud de la aleta en mm",
       y = "Frecuencia absoluta") +
  guides(fill = guide_legend(title = "Especie")) +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"),
        legend.title = element_text(size=20))
```

## Cruzando una variable cuantitativa con una cualitativa

```{r, out.height='60%', out.width='60%', fig.align='center', message=FALSE, echo=FALSE}
ggplot(data = penguins, aes(x = flipper_length_mm)) +
  geom_histogram(aes(fill = species), 
                 alpha = 0.5, 
                 position = "identity",
                 na.rm = TRUE) +
  scale_fill_manual(values = c("darkorange","purple","cyan4")) +
  labs(x = "Longitud de la aleta en mm",
       y = "Frecuencia absoluta") +
  guides(fill = guide_legend(title = "Especie")) +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"),
        legend.title = element_text(size=20))
```

## Cruzando una variable cuantitativa con una cualitativa

Para que el gráfico sea más claro, se los puede separar con facetas: `facet_grid(.~species)` justo después de la capa geom_histogram.

```{r, out.height='60%', out.width='60%', fig.align='center', message=FALSE, echo=FALSE, message=FALSE}
ggplot(data = penguins, aes(x = flipper_length_mm)) +
  geom_histogram(aes(fill = species), 
                 alpha = 0.5, 
                 position = "identity",
                 na.rm = TRUE) +
  facet_grid(.~species) +
  scale_fill_manual(values = c("darkorange","purple","cyan4")) +
  labs(x = "Longitud de la aleta en mm",
       y = "Frecuencia absoluta") +
  guides(fill = guide_legend(title = "Especie")) +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"),
        legend.title = element_text(size=20))
```


## Cruzando una variable cuantitativa con una cualitativa

* La capa `facet_grid` admite dos variables como argumento, separadas por ~, las categorías de la primera definen las filas y las de la segunda, las columnas.  Si solo se usa una, se ubica un punto en el lugar de la otra.

* Otra forma muy conveniente de cruzar una variable cuantitativa con otra cualitativa es usando boxplots. 

```{r, eval=FALSE}
ggplot(data = penguins, aes(x = species, y = flipper_length_mm)) +
  geom_boxplot(aes(color = species), width = 0.3, 
               show.legend = FALSE) + 
  geom_jitter(aes(color = species), alpha = 0.5, 
              show.legend = FALSE, 
              position = position_jitter(width = 0.2, seed = 0)) +
  scale_color_manual(values = c("darkorange","purple","cyan4")) +
  labs(x = "Epecie", y = "Longitud de la aleta en mm")
```

## Cruzando una variable cuantitativa con una cualitativa

```{r, out.height='50%', out.width='60%', fig.align='center', message=FALSE, warning=FALSE, echo=FALSE}
ggplot(data = penguins, aes(x = species, 
                            y = flipper_length_mm)) +
  geom_boxplot(aes(color = species),
               width = 0.3, show.legend = FALSE) +
  geom_jitter(aes(color = species), alpha = 0.5, 
              show.legend = FALSE, 
              position = position_jitter(width = 0.2, seed = 0)) +
  scale_color_manual(values = c("darkorange","purple","cyan4")) +
  labs(x = "Epecie",
       y = "Longitud de la aleta en mm") +
  theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"),
        legend.title = element_text(size=20))
```

## Cruzando dos variables cuantitativas

```{r, eval=FALSE}
ggplot(penguins) +
  geom_point(mapping = aes(x = flipper_length_mm,
                           y = body_mass_g,
                           color = sex), size=3)+ theme_bw() +
  theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"),
        legend.title = element_text(size=20)) + 
  guides(fill = guide_legend(title = "Sexo"))
```
## Cruzando dos variables cuantitativas

```{r, out.height='60%', out.width='60%', fig.align='center', message=FALSE, warning=FALSE, echo=FALSE}
ggplot(penguins) +
  geom_point(mapping = aes(x=flipper_length_mm,y = body_mass_g,color = sex), size=3)+ theme_bw()+
  labs(x = "Longitud de la aleta en mm",
       y = "Masa corporal en gramos") +
  guides(fill = guide_legend(title = "Sexo")) +  
theme(axis.text = element_text(size=20),
        axis.title = element_text(size=20, face = "bold"),
        legend.title = element_text(size=20)) 
```


## Códigos de color html

* Para obtener colores realmente personalizados, puede consultar los [códigos de color HTML](https://www.w3schools.com/colors/colors_picker.asp) (también llamados *códigos hexadecimales*, por ejemplo, `#ff0000` para el rojo) en lugar de especificar los colores por su [nombre predefinido](http://sape.inf.usi.ch/quick-reference/ggplot2/colour) en `R`.
]

* Hexcodes: códigos que especifican el nivel de intensidad del color rojo (dos primeros), verde (dos segundos) y azul (dos últimos dígitos)

* La familia de funciones `scale_colour_*()` permite ajustar los valores de la estética `color` (por ejemplo, `scale_colour_brewer()` selecciona una paleta del famoso proyecto [ColorBrewer](https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3)). 


## Integrando las herramientas de tidyverse ...


```{r, message=FALSE, warning=FALSE}
penguins_long <- penguins %>% 
  tidyr::pivot_longer(
    cols = contains("mm"),
    names_to = "var", values_to = "val") %>% 
  tidyr::drop_na()
```

```{r, eval=FALSE}
penguins_long %>% 
  ggplot(aes(x = var, y = val, fill=var)) +
  geom_boxplot() +
  theme_bw() +
  theme(legend.position="none") +
  labs(x="", y="Medida en mm")
```

## Integrando las herramientas de tidyverse ...

```{r, echo=FALSE, out.height='50%', out.width='50%', fig.align='center', message=FALSE, warning=FALSE}
penguins_long %>% 
  ggplot(aes(x = var, y = val, fill=var)) +
  geom_boxplot() +
  theme_bw() +
  theme(legend.position="none") +
  labs(x="", y="Medida en mm") +
  theme(axis.text = element_text(size=20),
axis.title = element_text(size=20, face = "bold"),
legend.title = element_text(size=20)) 
```

## Integrando las herramientas de tidyverse ...

```{r, out.height='40%', out.width='60%', fig.align='center'}
penguins %>%
  dplyr::count(species) %>%
  dplyr::mutate(prop = n / sum(n)) %>%
  ggplot() + geom_col(aes(x = prop, y = species)) +
  labs(x="Proporción", y="") + 
  theme(axis.text = element_text(size=20),
axis.title = element_text(size=20, face = "bold"),
legend.title = element_text(size=20)) 
```

## Extensiones de ggplot

Hay muchas extensiones de ggplot. Ver https://exts.ggplot2.tidyverse.org/gallery/

```{r, echo=FALSE, out.width='80%',fig.align='center'}
knitr::include_graphics("Imgs/extensiones.png")
```

## Extensiones de ggplot

\blue{GGally} contiene extensiones de ggplo2 para datos multivariantes

```{r, eval=FALSE}
library(GGally)
library(gapminder)
gapminder %>% select(-country,-year) %>% 
  ggpairs(aes(color=continent))
```

## Extensiones de ggplot


```{r, echo=FALSE,message=FALSE, warning=FALSE, out.width='60%',fig.align='center'}
library(GGally)
library(gapminder)
gapminder %>% select(-country,-year) %>% 
  ggpairs(aes(color=continent))
```

## Extensiones de ggplot

\blue{ggpubr} proporciona algunas funciones fáciles de usar para crear y personalizar gráficos útiles para una publicación.

```{r, echo=FALSE, out.width='50%', out.height='50%', fig.align='center'}
knitr::include_graphics("Imgs/violin.PNG")
```

Puedes ver más ejemplos en https://rpkgs.datanovia.com/ggpubr/index.html

## Para cerrar ...

En https://allisonhorst.github.io/palmerpenguins/articles/examples.html puedes encontrar otros ejemplos de gráficos usando los datos de los pingüinos.
\
En un documento aparte, con extensión html, trataremos cómo hacer gráficos interactivos.

